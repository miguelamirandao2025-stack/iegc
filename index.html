<html lang="es">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Serpiente Galáctica</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;700&display=swap" rel="stylesheet">
    <style>
        :root {
            --color-worm: #6AA84F; /* Verde para la lombriz */
            --worm-border: #446633; /* Borde oscuro para el segmento de la lombriz */
            --color-golden-apple: #FFC436; /* Amarillo dorado */
            --color-galaxy-dark: #0A0A1F; /* Azul muy oscuro/galáctico */
            --color-galaxy-mid: #151540;
            --board-border-color: #3A5795; /* Nuevo borde azul oscuro para el tablero */
            --obstacle-color: #555555; /* Color para los obstáculos (rocas espaciales) */
            --font-family: 'Inter', sans-serif;
        }

        body {
            font-family: var(--font-family);
            background-color: var(--color-galaxy-dark);
            color: white;
            display: flex;
            justify-content: center;
            align-items: center;
            min-height: 100vh;
            padding: 20px;
        }

        .game-container {
            background-color: var(--color-galaxy-mid);
            border: 8px solid var(--board-border-color); /* Usando el nuevo borde azul */
            border-radius: 20px;
            box-shadow: 0 10px 30px rgba(255, 255, 255, 0.1), 0 0 50px rgba(255, 196, 54, 0.2);
            padding: 20px;
            display: flex;
            flex-direction: column;
            align-items: center;
        }

        #gameCanvas {
            border: 2px solid var(--color-galaxy-dark);
            background: linear-gradient(135deg, var(--color-galaxy-dark) 0%, #00000A 100%);
            border-radius: 8px;
            box-shadow: inset 0 0 15px rgba(0, 0, 0, 0.5);
            touch-action: none; /* Previene el comportamiento de deslizamiento del navegador en dispositivos táctiles */
        }

        .hud {
            width: 100%;
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 15px;
            font-size: 1.25rem;
            font-weight: bold;
            color: #C0C0C0;
        }

        .game-message {
            position: absolute;
            top: 0; bottom: 0; left: 0; right: 0;
            background-color: rgba(0, 0, 0, 0.8);
            backdrop-filter: blur(5px);
            border-radius: 8px;
            display: none;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            text-align: center;
            padding: 20px;
            z-index: 10;
        }

        .game-message h2 {
            font-size: 2.5rem;
            color: var(--color-golden-apple);
            margin-bottom: 15px;
            text-shadow: 0 0 10px var(--color-golden-apple);
        }

        .game-message p {
            font-size: 1.5rem;
            color: white;
            margin-bottom: 30px;
        }

        .control-panel {
            margin-top: 20px;
            display: flex;
            flex-direction: column;
            align-items: center;
        }

        .control-grid {
            display: grid;
            grid-template-areas: ". up ." "left down right";
            gap: 10px;
            margin-top: 10px;
        }

        .control-button {
            padding: 15px 20px;
            background-color: var(--color-worm);
            color: white;
            font-size: 1.5rem;
            font-weight: bold;
            border: none;
            border-radius: 10px;
            cursor: pointer;
            box-shadow: 0 4px 0 var(--worm-border); /* Sombra de la lombriz para los botones */
            transition: all 0.1s ease;
            width: 80px;
            height: 80px;
            display: flex;
            justify-content: center;
            align-items: center;
            user-select: none;
        }

        .control-button:active {
            transform: translateY(4px);
            box-shadow: 0 0 0 var(--worm-border);
        }

        #btnUp { grid-area: up; }
        #btnLeft { grid-area: left; }
        #btnDown { grid-area: down; }
        #btnRight { grid-area: right; }

        @media (min-width: 640px) {
            .game-container {
                width: 500px;
            }
        }
        @media (max-width: 640px) {
            .game-container {
                width: 100%;
                max-width: 400px;
            }
            .control-grid {
                gap: 5px;
            }
            .control-button {
                width: 60px;
                height: 60px;
                font-size: 1.2rem;
            }
            .game-message h2 {
                font-size: 2rem;
            }
            .game-message p {
                font-size: 1.2rem;
            }
        }
    </style>
</head>
<body>

    <div class="game-container relative">
        <h1 class="text-3xl font-bold mb-4 text-center">Lombriz Galáctica</h1>

        <div class="hud">
            <span id="scoreText">Puntuación: 0</span>
            <span id="speedText">Velocidad: Lenta</span>
        </div>

        <canvas id="gameCanvas" width="400" height="400"></canvas>

        <div id="gameOverMessage" class="game-message">
            <h2>¡Juego Terminado!</h2>
            <p id="finalScoreText"></p>
            <button id="restartButton" class="control-button">Volver a Jugar</button>
        </div>

        <!-- Controles Táctiles (para móviles) -->
        <div class="control-panel md:hidden">
            <p class="text-lg mb-2 text-gray-400">Controles Táctiles</p>
            <div class="control-grid">
                <button id="btnUp" class="control-button" data-dir="Up">▲</button>
                <button id="btnLeft" class="control-button" data-dir="Left">◀</button>
                <button id="btnDown" class="control-button" data-dir="Down">▼</button>
                <button id="btnRight" class="control-button" data-dir="Right">▶</button>
            </div>
        </div>

    </div>

    <script>
        // --- Constantes del Juego ---
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');
        const scoreText = document.getElementById('scoreText');
        const speedText = document.getElementById('speedText');
        const gameOverMessage = document.getElementById('gameOverMessage');
        const finalScoreText = document.getElementById('finalScoreText');
        const restartButton = document.getElementById('restartButton');
        const TILE_SIZE = 20; // Tamaño de cada segmento de la serpiente/lombriz
        const CANVAS_WIDTH = canvas.width;
        const CANVAS_HEIGHT = canvas.height;
        const TILE_COUNT = CANVAS_WIDTH / TILE_SIZE;

        // --- Estado del Juego ---
        let snake = [];
        let food = {};
        let obstacles = []; // NUEVO: array para obstáculos
        let dx = TILE_SIZE; // Dirección X (inicio a la derecha)
        let dy = 0;      // Dirección Y
        let score = 0;
        let gameLoopInterval = null;
        let baseSpeed = 150; // Velocidad inicial en ms
        let currentSpeed = baseSpeed;
        let isGameOver = false;
        let changingDirection = false; // Bandera para evitar doble movimiento por tick

        // --- Estética y Colores ---
        const COLOR_WORM = '#6AA84F'; // Verde para la lombriz (Actualizado)
        const COLOR_WORM_BORDER = '#446633'; // Borde de la lombriz
        const COLOR_OBSTACLE = '#555555'; // Gris oscuro para obstáculo
        const COLOR_GOLDEN_APPLE = '#FFC436'; // Amarillo dorado
        const COLOR_STAR_LIGHT = 'rgba(255, 255, 255, 0.7)';
        const STAR_COUNT = 150;
        const stars = [];

        // --- Inicialización de Estrellas ---
        function initializeStars() {
            for (let i = 0; i < STAR_COUNT; i++) {
                stars.push({
                    x: Math.random() * CANVAS_WIDTH,
                    y: Math.random() * CANVAS_HEIGHT,
                    radius: Math.random() * 1.5 + 0.5,
                    opacity: Math.random()
                });
            }
        }

        // --- Funciones de Dibujo ---

        // Dibuja el fondo galáctico con estrellas
        function drawBackground() {
            ctx.fillStyle = getComputedStyle(document.documentElement).getPropertyValue('--color-galaxy-dark');
            ctx.fillRect(0, 0, CANVAS_WIDTH, CANVAS_HEIGHT);

            // Dibujar estrellas
            stars.forEach(star => {
                ctx.beginPath();
                ctx.arc(star.x, star.y, star.radius, 0, 2 * Math.PI);
                ctx.fillStyle = COLOR_STAR_LIGHT;
                ctx.globalAlpha = star.opacity;
                ctx.fill();
            });
            ctx.globalAlpha = 1.0; // Resetear opacidad
        }

        // Dibuja la lombriz
        function drawSnake() {
            snake.forEach((segment, index) => {
                // Sombra para dar volumen de "lombriz"
                ctx.shadowColor = 'rgba(0, 0, 0, 0.8)';
                ctx.shadowBlur = 8;
                ctx.shadowOffsetX = 3;
                ctx.shadowOffsetY = 3;

                // Color del cuerpo
                ctx.fillStyle = COLOR_WORM;
                ctx.fillRect(segment.x, segment.y, TILE_SIZE, TILE_SIZE);

                // Borde oscuro para definir los segmentos
                ctx.strokeStyle = COLOR_WORM_BORDER; // Usamos el nuevo borde verde oscuro
                ctx.lineWidth = 1;
                ctx.strokeRect(segment.x, segment.y, TILE_SIZE, TILE_SIZE);

                // Ojos para la cabeza (índice 0)
                if (index === 0) {
                    ctx.fillStyle = 'black';
                    ctx.beginPath();
                    // Ojo izquierdo
                    ctx.arc(segment.x + TILE_SIZE * 0.3, segment.y + TILE_SIZE * 0.3, 2, 0, Math.PI * 2);
                    // Ojo derecho
                    ctx.arc(segment.x + TILE_SIZE * 0.7, segment.y + TILE_SIZE * 0.3, 2, 0, Math.PI * 2);
                    ctx.fill();
                }

                // Reiniciar sombra
                ctx.shadowColor = 'transparent';
                ctx.shadowBlur = 0;
                ctx.shadowOffsetX = 0;
                ctx.shadowOffsetY = 0;
            });
        }

        // Dibuja la manzana dorada
        function drawFood() {
            // Brillo y sombra dorada
            ctx.shadowColor = COLOR_GOLDEN_APPLE;
            ctx.shadowBlur = 15;
            ctx.shadowOffsetX = 0;
            ctx.shadowOffsetY = 0;

            // Forma base: Círculo (Manzana simplificada)
            const centerX = food.x + TILE_SIZE / 2;
            const centerY = food.y + TILE_SIZE / 2;
            const radius = TILE_SIZE * 0.4;

            // Gradiente para el efecto "Dorado"
            const gradient = ctx.createRadialGradient(centerX, centerY, 1, centerX, centerY, radius);
            gradient.addColorStop(0, '#FFF59D'); // Centro brillante
            gradient.addColorStop(0.5, COLOR_GOLDEN_APPLE);
            gradient.addColorStop(1, '#B8860B'); // Borde oscuro/oro viejo

            ctx.fillStyle = gradient;
            ctx.beginPath();
            ctx.arc(centerX, centerY, radius, 0, 2 * Math.PI);
            ctx.fill();

            // Reiniciar sombra
            ctx.shadowColor = 'transparent';
            ctx.shadowBlur = 0;
        }

        // NUEVO: Dibuja los obstáculos (rocas espaciales)
        function drawObstacles() {
            obstacles.forEach(obstacle => {
                ctx.fillStyle = COLOR_OBSTACLE;
                ctx.shadowColor = 'rgba(0, 0, 0, 0.9)';
                ctx.shadowBlur = 10;

                // Dibujar una forma irregular simple para simular una roca espacial
                const radius = TILE_SIZE * 0.45;
                const centerX = obstacle.x + TILE_SIZE / 2;
                const centerY = obstacle.y + TILE_SIZE / 2;

                ctx.beginPath();
                ctx.moveTo(centerX + radius, centerY);
                ctx.lineTo(centerX + radius * 0.5, centerY + radius * 0.8);
                ctx.lineTo(centerX - radius * 0.5, centerY + radius * 0.9);
                ctx.lineTo(centerX - radius, centerY + radius * 0.2);
                ctx.lineTo(centerX - radius * 0.7, centerY - radius * 0.7);
                ctx.lineTo(centerX + radius * 0.2, centerY - radius * 0.9);
                ctx.closePath();
                ctx.fill();

                // Detalle de sombra/relieve para la roca
                ctx.fillStyle = '#666666';
                ctx.fillRect(obstacle.x + TILE_SIZE * 0.1, obstacle.y + TILE_SIZE * 0.1, TILE_SIZE * 0.15, TILE_SIZE * 0.15);
                ctx.fillRect(obstacle.x + TILE_SIZE * 0.7, obstacle.y + TILE_SIZE * 0.6, TILE_SIZE * 0.1, TILE_SIZE * 0.1);

                ctx.shadowBlur = 0; // Resetear sombra
            });
        }

        // Dibuja todos los elementos del juego
        function drawGame() {
            drawBackground();
            drawFood();
            drawObstacles(); // Incluir el dibujo de obstáculos
            drawSnake();
        }

        // --- Lógica del Juego ---

        // NUEVO: Coloca obstáculos fijos en el tablero
        function placeObstacles() {
            obstacles = [];
            const OBSTACLE_COUNT = 8; // Número de obstáculos

            for (let i = 0; i < OBSTACLE_COUNT; i++) {
                let newObstacle = {};
                let isOverlapping;
                let attempts = 0;

                do {
                    newObstacle.x = Math.floor(Math.random() * TILE_COUNT) * TILE_SIZE;
                    newObstacle.y = Math.floor(Math.random() * TILE_COUNT) * TILE_SIZE;

                    // 1. Comprobar si solapa con la posición inicial de la Lombriz (primeros 5 segmentos)
                    const isOverSnake = snake.slice(0, 5).some(segment => segment.x === newObstacle.x && segment.y === newObstacle.y);

                    // 2. Comprobar si solapa con otros Obstáculos
                    const isOverObstacle = obstacles.some(obs => obs.x === newObstacle.x && obs.y === newObstacle.y);

                    isOverlapping = isOverSnake || isOverObstacle;
                    attempts++;
                } while (isOverlapping && attempts < 100); // Prevenir bucle infinito

                if (attempts < 100) {
                    obstacles.push(newObstacle);
                }
            }
        }


        // Coloca la comida en una posición aleatoria que no esté ocupada
        function placeFood() {
            let newFood = {};
            let isOverlapping;
            do {
                // Generar coordenadas aleatorias alineadas a la cuadrícula
                newFood.x = Math.floor(Math.random() * TILE_COUNT) * TILE_SIZE;
                newFood.y = Math.floor(Math.random() * TILE_COUNT) * TILE_SIZE;

                // Comprobar si solapa con la lombriz O con un obstáculo (ACTUALIZADO)
                const isOverSnake = snake.some(segment => segment.x === newFood.x && segment.y === newFood.y);
                const isOverObstacle = obstacles.some(obs => obs.x === newFood.x && obs.y === newFood.y);

                isOverlapping = isOverSnake || isOverObstacle;

            } while (isOverlapping);

            food = newFood;
        }

        // Mueve la serpiente un paso
        function moveSnake() {
            // Crear la nueva cabeza
            const head = { x: snake[0].x + dx, y: snake[0].y + dy };
            snake.unshift(head); // Añadir la nueva cabeza al principio

            // Comprobar si come la comida
            if (head.x === food.x && head.y === food.y) {
                // Si come, no eliminar la cola (la serpiente crece)
                score++;
                updateScoreAndSpeed();
                placeFood();
            } else {
                // Si no come, eliminar la cola
                snake.pop();
            }
            changingDirection = false;
        }

        // Comprueba colisiones (paredes, consigo mismo, u obstáculos)
        function checkCollisions() {
            const head = snake[0];

            // Colisión con la pared
            if (head.x < 0 || head.x >= CANVAS_WIDTH || head.y < 0 || head.y >= CANVAS_HEIGHT) {
                return true;
            }

            // Colisión consigo mismo
            for (let i = 1; i < snake.length; i++) {
                if (head.x === snake[i].x && head.y === snake[i].y) {
                    return true;
                }
            }
            
            // NUEVO: Colisión con los obstáculos
            if (obstacles.some(obs => obs.x === head.x && obs.y === head.y)) {
                return true;
            }

            return false;
        }

        // Bucle principal del juego
        function gameLoop() {
            if (isGameOver) return;

            if (checkCollisions()) {
                endGame();
                return;
            }

            moveSnake();
            drawGame();
        }

        // Actualiza la puntuación y la velocidad de juego
        function updateScoreAndSpeed() {
            scoreText.textContent = `Puntuación: ${score}`;

            // Lógica de aceleración (cada 5 puntos)
            let newSpeed;
            if (score % 5 === 0 && score > 0) {
                 // Reducir el intervalo (acelerar)
                const speedFactor = 0.9;
                newSpeed = Math.max(70, baseSpeed * (speedFactor ** (score / 5)));
            } else {
                newSpeed = currentSpeed;
            }

            // Si la velocidad ha cambiado significativamente, reiniciar el intervalo
            if (newSpeed !== currentSpeed) {
                currentSpeed = newSpeed;
                clearInterval(gameLoopInterval);
                gameLoopInterval = setInterval(gameLoop, currentSpeed);
            }

            // Actualizar texto de velocidad
            let speedLabel;
            if (currentSpeed >= 130) {
                speedLabel = "Lenta";
            } else if (currentSpeed >= 100) {
                speedLabel = "Normal";
            } else if (currentSpeed >= 80) {
                speedLabel = "Rápida";
            } else {
                speedLabel = "Extrema";
            }
            speedText.textContent = `Velocidad: ${speedLabel}`;
        }

        // --- Control de Dirección ---
        function changeDirection(event) {
            if (changingDirection) return;

            const keyPressed = event.key;
            const direction = event.target.dataset.dir || keyPressed; // Para botones táctiles
            const goingUp = dy === -TILE_SIZE;
            const goingDown = dy === TILE_SIZE;
            const goingRight = dx === TILE_SIZE;
            const goingLeft = dx === -TILE_SIZE;

            if (direction === 'ArrowLeft' || direction === 'Left') {
                if (!goingRight) { dx = -TILE_SIZE; dy = 0; changingDirection = true; }
            } else if (direction === 'ArrowUp' || direction === 'Up') {
                if (!goingDown) { dx = 0; dy = -TILE_SIZE; changingDirection = true; }
            } else if (direction === 'ArrowRight' || direction === 'Right') {
                if (!goingLeft) { dx = TILE_SIZE; dy = 0; changingDirection = true; }
            } else if (direction === 'ArrowDown' || direction === 'Down') {
                if (!goingUp) { dx = 0; dy = TILE_SIZE; changingDirection = true; }
            }
        }

        // --- Inicio y Fin del Juego ---
        function initGame() {
            snake = [
                { x: TILE_SIZE * 4, y: TILE_SIZE * 10 },
                { x: TILE_SIZE * 3, y: TILE_SIZE * 10 },
                { x: TILE_SIZE * 2, y: TILE_SIZE * 10 },
                { x: TILE_SIZE * 1, y: TILE_SIZE * 10 },
            ];
            dx = TILE_SIZE;
            dy = 0;
            score = 0;
            currentSpeed = baseSpeed;
            isGameOver = false;
            changingDirection = false;

            placeObstacles(); // NUEVO: Colocar obstáculos
            gameOverMessage.style.display = 'none';
            updateScoreAndSpeed();
            placeFood();
            drawGame(); // Dibujar el estado inicial

            if (gameLoopInterval) {
                clearInterval(gameLoopInterval);
            }
            gameLoopInterval = setInterval(gameLoop, currentSpeed);
        }

        function endGame() {
            isGameOver = true;
            clearInterval(gameLoopInterval);
            finalScoreText.textContent = `¡Lograste ${score} manzanas doradas!`;
            gameOverMessage.style.display = 'flex';
        }

        // --- Event Listeners ---
        document.addEventListener('keydown', (event) => {
            // Solo responder a las teclas de flecha
            if (['ArrowUp', 'ArrowDown', 'ArrowLeft', 'ArrowRight'].includes(event.key)) {
                event.preventDefault(); // Evita el desplazamiento de la página
                changeDirection(event);
            }
        });

        restartButton.addEventListener('click', initGame);

        // Configurar botones táctiles
        document.querySelectorAll('.control-button').forEach(button => {
            if (button.id !== 'restartButton') {
                button.addEventListener('click', (event) => {
                    changeDirection(event);
                });
            }
        });

        // --- Ejecución al cargar la ventana ---
        window.onload = function() {
            initializeStars();
            initGame();
        }

    </script>
</body>
</html>
